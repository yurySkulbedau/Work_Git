# Git для новичков
## Что такое Git и зачем он нужен?
Git - это консольная утилита для отслеживания и ведения истории изменения файлов в вашем проекте.

Git сохраняет в памяти не файлы целиком, а разницу в них. С помощью Git-a вы можете откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.

Репозиторием называют хранилище вашего кода и истории его изменений.

Так же ваши репозитории можно хранить и в интернете. Обычно для этого используют три сервиса:
* GitHub
* Bitbucket
* GitLab

Каждая точка сохранения вашего проекта носит название коммит (commit). У каждого commit-a есть hash (уникальный id) и комментарий. Из таких commit-ов собирается ветка. Ветка - это история изменений. У каждой ветки есть свое название. Репозиторий может содержать в себе несколько веток, которые создаются из других веток или вливаются в них.
## Настройка
Прежде чем создавать репозиторий и инициализировать Git, проверим текущую установленную версию пограммы. Для этого в терминале введем команду:
> git --version

Если Git установлен на компьютер, вы увидите его текущую версию.

Чтобы когда вы создавали commit, указывался автор, кто его создал, установим имя и почту пользователя (кавычки нужны)  
>git config --global user.name "<ваше_имя>"  
git config --global user.email "<адрес_почты@email.com>"
## Инициализация/создание репозитория
Чтобы начать слежение за существующим проектом, перейдите в папку этого проекта и введите команду
>*git init* 

В результате в существующей папке появится скрытая папка .git со всеми нужными файлами репозитория.

Чтобы начать управление версиями, укажите файлы, за которыми должна следить система, и выполните первую фиксацию изменений.   
Добавим все файлы проекта в наш будующий commit:  
>*git add .*  
или  
>*git add --all*  

Если хотим добавить в отслеживаемые конкретные файлы, потребуется несколько команд *git add*:  
>*git add <имя_файла>*  
*git add <имя_файла>*

Теперь создаем commit. Обязательно указываем комментарий (*m*essage).
И не забываем про кавычки  
>*git commit -m "Initial commit"*

## Запись изменений в репозиторий
Не стоит после каждого изменения файла делать commit. Чаще всего их создают, когда:
* Создан новый функционал
* Добавлен новый блок на верстке
* Исправлены ошибки по коду
* Вы завершили рабочий день и хотите сохранить код.

Это поможет держать ваши ветки в чистоте и порядке. Тем самым вы будете видеть историю изменений по каждому нововведению в вашем проекте, а не по каждому файлу.

### Проверка состояния файлов
>*git status*  
отображает состояние рабочего каталога и раздела проиндексированных файлов. С ее помощью можно проверить индексацию изменений и увидеть файлы, которые не отслеживаются Git.
### Слежение за новыми файлами
>*git add <имя_файла>* 

Теперь команда *git status* покажет, что этот файл является отслеживаемым и проиндексированным.
### Индексация измененных файлов
>В дальнейшем, перед командами *git add* или *git commit -am* не забывать сохранять файл!

Если отредактировать отслеживаемый файл и воспользоваться командой git status, файл появляется под заголовком *Changed but not staged for commit* — это означает, что отслеживаемый файл из рабочей папки был изменен, но пока не проиндексирован. Индексирование выполняется командой 
>*git add <имя_файла>*  
Это многоцелевая команда, позволяющая начать слежение за новыми файлами, произвести индексирование файлов, а также пометить файлы с конфликтом слияния как разрешенные. Целесообразнее воспринимать эту команду как *«добавление содержимого к следующему коммиту»*, а не как «добавление файла к проекту». 

Git индексирует файл в том состоянии, в котором он пребывал на момент выполнения команды git add. Если внести в файл изменения до его фиксации, в коммит войдет версия файла, появившаяся после последнего запуска команды git add, а не версия, находившаяся в рабочей папке при запуске команды git commit! Редактирование файла после выполнения команды git add требует повторного запуска этой команды для индексирования самой последней версии файла.
>*git diff* - разница между текущим файлом и сохраненным коммитом.
### Игнорирование файлов
Бывает так, что некоторый класс файлов вы не хотите ни автоматически добавлять в репозиторий, ни видеть в списке неотслеживаемых. Для этого создается файл *.gitignore* со списком соответствующих файлов и/или паттернов (сам файл .gitignore нужно добавить в список отслеживаемых)
>На сайте GitHub есть исчерпывающий список хороших примеров файла .gitignore для десятков проектов и языков. Он находится на странице https://github.com/github/gitignore. Им можно воспользоваться как отправной точкой для ваших собственных проектов.
### Фиксация изменений
>*git commit -m "<комментарий>"*  
фиксирует изменения.

При каждой фиксации вы записываете снимоксвоего проекта, к которому можно будет вернуться в любой момент или использовать его для сравнения с текущим состоянием.
### Пропуск области индексирования
Если передать команде *git commit* параметр *-a*, Git начнет автоматически индексировать **все** отслеживаемые файлы перед их фиксацией, позволяя обойтись без команды git add:
>*git commit -am "updated this section"*
### Удаление файлов
Чтобы Git перестал работать с файлом, его нужно удалить из числа отслеживаемых. Это делает команда 
>*git rm*  
которая заодно удаляет указанный файл из рабочей папки, благодаря чему он исчезает из списка неотслеживаемых.

После простого удаления файла из рабочей папки он появляется в разделе *Changed but not updated* (измененные, но необновленные) выводимых командой git status данных.

Иногда требуется оставить файл в рабочей папке, удалив его из области индексирования. В этом случае на помощь приходит параметр --cached:
>*git rm --cached <имя файла>*
## Просмотр истории версий
>*git log* - журнал изменений. Выводит список всех коммитов в хронологическом порядке.  
*git log --oneline* - краткая инфа. Достаточно, если работаешь один.
## Отмена изменений
Если после фиксации очередной версии вы обнаружили, что забыли проиндексировать изменения в одном из файлов, который планировалось включить в новый коммит, можно сделать так:
>*git commit -m 'изначальный коммит'  
git add <forgotten_file>  
git commit --amend*

В итоге у вас останется единственный коммит — второй коммит заменит результат первого.
### Отмена индексирования
Предположим, вы отредактировали два файла и хотели бы зафиксировать их в двух разных коммитах, но случайно набрали команду *git add .*, что привело к их одновременному индексированию.  
Для отмены индексирования следует воспользоваться командой 
>*git reset HEAD <имя файла>*
### Отмена внесенных в файл изменений
Как быстро отменить изменения и вернуть файл в состояние,
в котором он находился до последней фиксации? 
>*git checkout -- <имя файла>*  
Все внесенные в файл изменения пропадают — вы просто копируете в этот файл содержимое другого файла. Никогда не пользуйтесь этой командой, если не уверены, что данный файл вам больше не понадобится.

Перед переключением версии файла в Git используйте команду git log, чтобы увидеть количество сохранений и номер коммита.
>*git checkout ####* - переключение между версиями (где #### - первые символы номера коммита)

Чтобы продолжить работу над файлом: 
>*git checkout branchname* (где branchname - название ветви, в которой работаем).  
Таким образом мы возвращаемся на самую вершину ветки.

Git отслеживает файлы по имени!  
Если изменить имя файла, Git будет считать, что он удален. Вместо этого появится новый файл, название которого Git пока неизвестно. Он его еще не отслеживает. В этом случае мы можем добавить свой файл с правильным именем в отслеживаемые, сделать новый commit, и всё снова будет в порядке. А при помощи *checkout* можно всё еще вернуться к любой версии.

## Ветвления в Git
Ветка в Git представляет собой всего лишь указатель на один из коммитов. По умолчанию в Git ей присваивается имя *master*. Ее принято считать чистовиком.  
Если нужно добавить новую возможность или исправить ошибку, вы создаете новую ветку, в которой будут размещаться эти изменения.  
Разработка в отдельных ветках не только позволяет работать над ними параллельно, но и предотвращает попадание сомнительного кода в *master*.  
Вместо того чтобы копировать файлы из каталога в каталог, Git хранит ветку в виде ссылки на коммит. Получается, что ветка представляет собой вершину серии коммитов, а не контейнер для коммитов. История ветки распространяется через иерархические отношения с другими коммитами.
> *git branch*  
выводит список имеющихся веток. 

> *git branch <название ветки>*  
создает новую ветку (появится новый указатель на ваш текущий коммит).  
Откуда Git узнает, какой именно коммит является текущим? Для этого он хранит специальный указатель HEAD. В Git он указывает на локальную ветку, в которой вы находитесь в данный момент. Пока это все еще ветка master. Команда git branch всего лишь создала новую ветку, но не перевела вас в нее.

>*git checkout <название ветки>* - переход на ветку.

>*git log --graph*  
добавляет небольшой ASCII-граф с историей ветвлений и слияний для данной ветки

>*git log --oneline --graph --all*  
выводит историю коммитов, показывая места расположения указателей и точки расхождения.
### Основы ветвления
В качестве исходных условий представим, что уже есть пара коммитов проекта.
Вы решили приступить к работе над проблемой 53, фигурирующей в системе отслеживания ошибок вашей фирмы. Создать ветку и сразу перейти туда позволяет *git checkout* с параметром *-b*:
>*git checkout -b iss53* - переход на новую ветку "iss53"

Это сокращенная запись для команд:
>*git branch iss53*
>*git checkout iss53*

Вы работаете, несколько раз фиксируете состояние. При этом ветка iss53 смещается вперед, так как вы в ней находитесь.  
Вдруг - звонок с сообщением о проблеме. Благодаря Git вам не нужно выполнять развертывание исправлений вместе с внесенными в ветку iss53 изменениями или ценой массы усилий отменять эти изменения перед тем, как приступить к устранению проблемы. Достаточно вернуться в ветку *master* (предварительно зафиксировав все изменения в той ветке).  
Теперь рабочая папка проекта вернулась в то состояние, в котором она пребывала перед началом работы над проблемой 53, и можно сконцентрироваться на решении новой задачи - новая ветка hotfix.
>*git checkout -b hotfix  
.....  
>*git commit -a -m 'fixed the broken email address'

Убедившись, что найденное решение работает, можно объединить ветку *hotfix* с веткой *master*, чтобы внедрить внесенные изменения в готовый код. Эта операция выполняется командой **git merge**:
>*git checkout master*
>*git merge hotfix*

*git merge* вызывается из той ветки, в которую вы хотите залить изменения.

После внедрения важного исправления можно вернуться к прерванной работе. Но сначала следует удалить ветку *hotfix*, так как она нам больше не понадобится, — на этот коммит уже указывает ветка *master*.  
Для этого достаточно добавить параметр *-d* к команде git branch:
>*git branch -d hotfix

Теперь можно вернуться в ветку, где ведется работа над проблемой 53, и продолжить ее решение. Следует заметить, что изменения, внесенные в ветку *hotfix*, не касаются файлов из ветки *iss53*. Ситуацию можно изменить, слив ветку *master* с веткой *iss53*, — это делает команда *git merge master*. Или отложите этот процесс до момента, пока решите включить содержимое ветки *iss53* в ветку *master*.
## Другие советы и команды
>rm -R .git - удаление локального репозитория.

Не создавать репозиторий внутри другого репозитория!

Папка в терминале должна совпадать с папкой в проводнике (Explorer).

В терминале есть команда clear, очищающая поле от всех предыдущих записей.

## Подсказки при работе с VS Code
Для начала работы выбрать папку, после чего запустить терминал.

Чтобы вызвать ранее введенную команду, перебираем недавно введенные команды нажатием стрелки «вверх» на клавиатуре.

Писать название целиком не обязательно: терминал дозаполнит данные автоматически, если нажать Tab после нескольки символов.

Нажатие клавиши ‘q’ возвращает в исходное окно терминала.
