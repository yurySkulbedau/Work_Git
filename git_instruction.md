# Git для новичков
## Что такое Git и зачем он нужен?
Git - это консольная утилита для отслеживания и ведения истории изменения файлов в вашем проекте.

Git сохраняет в памяти не файлы целиком, а разницу в них. С помощью Git-a вы можете откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.

Репозиторием называют хранилище вашего кода и истории его изменений.

Так же ваши репозитории можно хранить и в интернете. Обычно для этого используют:
* GitHub
* Bitbucket
* GitLab

Каждая точка сохранения вашего проекта носит название коммит (commit). У каждого commit-a есть hash (уникальный id) и комментарий. Из таких commit-ов собирается ветка. Ветка - это история изменений. У каждой ветки есть свое название. Репозиторий может содержать в себе несколько веток, которые создаются из других веток или вливаются в них.
## Настройка
Прежде чем создавать репозиторий и инициализировать Git, проверим текущую установленную версию пограммы. Для этого в терминале введем команду:
> git --version

Если Git установлен на компьютер, вы увидите его текущую версию.

Чтобы когда вы создавали commit, указывался автор, кто его создал, установим имя и почту пользователя (кавычки нужны)  
>git config --global user.name "<ваше_имя>"  
git config --global user.email "<адрес_почты@email.com>"
## Инициализация/создание репозитория
>Прежде чем вызывать команды *git init* или *git clone*, сначала убедитесь (вызовом *git status*), что вы точно не внутри репозитория.

Чтобы начать слежение за существующим проектом, перейдите в папку этого проекта и введите команду
>*git init* 

В результате в существующей папке появится скрытая папка .git со всеми нужными файлами репозитория.

Чтобы начать управление версиями, укажите файлы, за которыми должна следить система, и выполните первую фиксацию изменений.   
Добавим все файлы проекта в наш будующий commit:  
>*git add .*  
или  
>*git add --all*  

Если хотим добавить в отслеживаемые конкретные файлы, потребуется несколько команд *git add*:  
>*git add <имя_файла>*  
*git add <имя_файла>*

Теперь создаем commit. Обязательно указываем комментарий (*m*essage).
И не забываем про кавычки  
>*git commit -m "Initial commit"*
###Клонирование существующего репозитория
Прежде чем скопировать репозиторий, находящийся на сервисе GitHub, в наш локальный репозиторий, вызовем команду *git status*. Убедимся, что здесь лежит пустая папка без каких-либо репозиториев.

Клонирование внешнего репозитория осуществляется командой 
>*git clone [url]*

Создается папка, инициализируется **в ней** .git (смотри, чтобы не было репозитория внутри репозитория!), считываются из репозитория все данные и выгружается рабочая копия последней версии.  
Необходимо в эту папку перейти командой *cd <название_папки>* в терминале.
## Запись изменений в репозиторий
Не стоит после каждого изменения файла делать commit. Чаще всего их создают, когда:
* Создан новый функционал
* Добавлен новый блок на верстке
* Исправлены ошибки по коду
* Вы завершили рабочий день и хотите сохранить код.

Это поможет держать ваши ветки в чистоте и порядке. Тем самым вы будете видеть историю изменений по каждому нововведению в вашем проекте, а не по каждому файлу.

### Проверка состояния файлов
>*git status*  
отображает состояние рабочего каталога и раздела проиндексированных файлов. С ее помощью можно проверить индексацию изменений и увидеть файлы, которые не отслеживаются Git.
### Слежение за новыми файлами
>*git add <имя_файла>* 

Теперь команда *git status* покажет, что этот файл является отслеживаемым и проиндексированным.
### Индексация измененных файлов
>В дальнейшем, перед командами *git add* или *git commit -am* не забывать сохранять файл!

Если отредактировать отслеживаемый файл и воспользоваться командой git status, файл появляется под заголовком *Changed but not staged for commit* — это означает, что отслеживаемый файл из рабочей папки был изменен, но пока не проиндексирован. Индексирование выполняется командой 
>*git add <имя_файла>*  
Это многоцелевая команда, позволяющая начать слежение за новыми файлами, произвести индексирование файлов, а также пометить файлы с конфликтом слияния как разрешенные. Целесообразнее воспринимать эту команду как *«добавление содержимого к следующему коммиту»*, а не как «добавление файла к проекту». 

Git индексирует файл в том состоянии, в котором он пребывал на момент выполнения команды git add. Если внести в файл изменения до его фиксации, в коммит войдет версия файла, появившаяся после последнего запуска команды git add, а не версия, находившаяся в рабочей папке при запуске команды git commit! Редактирование файла после выполнения команды git add требует повторного запуска этой команды для индексирования самой последней версии файла.
>*git diff* - разница между текущим файлом и сохраненным коммитом.
### Игнорирование файлов
Бывает так, что некоторый класс файлов вы не хотите ни автоматически добавлять в репозиторий, ни видеть в списке неотслеживаемых. Для этого создается файл *.gitignore* со списком соответствующих файлов и/или паттернов (сам файл .gitignore нужно добавить в список отслеживаемых).

It's a best practice to create a .gitignore file with all the files and the different file patterns you want to ignore when you create a new repository – before committing it.

If you want to ignore a *text.txt* file located in the root directory:
>/text.txt

a *text.txt* file located in a *test* directory at the root directory:
>test/text.txt

>text.txt - this pattern will ignore *all files with that particular name* that are located *anywhere* in the project.

>test/ - this command will ignore any directory (including other files and other sub-directories inside the directory) named *test* located anywhere in your project.

if you write the name of a file alone or the name of the directory alone without the slash **/** :
>test  
this pattern will match *both any files or directories* with that name:

>img* - will ignore all files and directories that have a name *starting with img*.

>*.md - will match any file *ending with the .md* extension located anywhere in the project.

>.md  
!README.md 

-- with both of those patterns in the .gitignore file, all files ending in .md get ignored except for the README.md file.

>На сайте GitHub есть список хороших примеров файла .gitignore для десятков проектов и языков. Он находится на странице https://github.com/github/gitignore.
### Фиксация изменений
>*git commit -m "<комментарий>"*  
фиксирует изменения.

При каждой фиксации вы записываете снимок своего проекта, к которому можно будет вернуться в любой момент или использовать его для сравнения с текущим состоянием.
### Пропуск области индексирования
Если передать команде *git commit* параметр *-a*, Git начнет автоматически индексировать **все** отслеживаемые файлы перед их фиксацией, позволяя обойтись без команды git add:
>*git commit -am "updated this section"*
### Удаление файлов
Чтобы Git перестал работать с файлом, его нужно удалить из числа отслеживаемых. Это делает команда 
>*git rm*  
которая заодно удаляет указанный файл из рабочей папки, благодаря чему он исчезает из списка неотслеживаемых.

После простого удаления файла из рабочей папки он появляется в разделе *Changed but not updated* (измененные, но необновленные) выводимых командой git status данных.

Иногда требуется оставить файл в рабочей папке, удалив его из области индексирования. В этом случае на помощь приходит параметр --cached:
>*git rm --cached <имя файла>*

Если целую папку:
>*git rm -r --cached <название папки>*
## Просмотр истории версий
>*git log* - журнал изменений. Выводит список всех коммитов в хронологическом порядке.  
*git log --oneline* - краткая инфа. Достаточно, если работаешь один.
## Отмена изменений
Если после фиксации очередной версии вы обнаружили, что забыли проиндексировать изменения в одном из файлов, который планировалось включить в новый коммит, можно сделать так:
>*git commit -m 'изначальный коммит'  
git add <forgotten_file>  
git commit --amend*

В итоге у вас останется единственный коммит — второй коммит заменит результат первого.
### Отмена индексирования
Предположим, вы отредактировали два файла и хотели бы зафиксировать их в двух разных коммитах, но случайно набрали команду *git add .*, что привело к их одновременному индексированию.  
Для отмены индексирования следует воспользоваться командой 
>*git reset HEAD <имя файла>*
### Отмена внесенных в файл изменений
Как быстро отменить изменения и вернуть файл в состояние,
в котором он находился до последней фиксации? 
>*git checkout -- <имя файла>*  
Все внесенные в файл изменения пропадают — вы просто копируете в этот файл содержимое другого файла. Никогда не пользуйтесь этой командой, если не уверены, что данный файл вам больше не понадобится.

Перед переключением версии файла в Git используйте команду git log, чтобы увидеть количество сохранений и номер коммита.
>*git checkout ####* - переключение между версиями (где #### - первые символы номера коммита)

Чтобы продолжить работу над файлом: 
>*git checkout branchname* (где branchname - название ветви, в которой работаем).  
Таким образом мы возвращаемся на самую вершину ветки.

Git отслеживает файлы по имени!  
Если изменить имя файла, Git будет считать, что он удален. Вместо этого появится новый файл, название которого Git пока неизвестно. Он его еще не отслеживает. В этом случае мы можем добавить свой файл с правильным именем в отслеживаемые, сделать новый commit, и всё снова будет в порядке. А при помощи *checkout* можно всё еще вернуться к любой версии.
## Удаленные репозитории
Когда мы привязали наш удалённый репозиторий к локальному (при создании GitHub подскажет, как это сделать), можем просто вызвать команду 
>*git push*, которая направит на внешний репозиторий все произведенные изменения.

Чтобы взять актуальную версию с GitHub и синхронизировать с локальным репозиторием:
>*git pull* 

Из репозитория remote стянутся все изменения.  
!*pull* не только подгрузит все изменения, но и попытается смержить наши ветки.

Чтобы поучаствовать в другом проекте, репозиторий которого есть на GitHub, нужно сделать копию этого репозитория. Для этого используется кнопка *Fork*. Делаем *git clone* **своей** версии репозитория. Любые изменения принято делать в специально созданной ветке. По завершению своих правок сделать коммит и выполнить *git push* (Git подскажет правильную команду, которую надо ввести), затем на GitHub (в оригинальном репозитории) сделать *Pull request*

Чтобы актуализировать *fork*, на GitHub, в своем репозитории нажать *Sync fork* -> *Update branch*. После - в терминале ввести *git pull*.
## Ветвления в Git
Ветка в Git представляет собой всего лишь указатель на один из коммитов. По умолчанию ветке в Git присваивается имя *master*. Ее принято считать чистовиком.  
Если нужно добавить новую возможность или исправить ошибку, вы создаете новую ветку, в которой будут размещаться эти изменения.  
Разработка в отдельных ветках не только позволяет работать над ними параллельно, но и предотвращает попадание сомнительного кода в *master*.  
Вместо того чтобы копировать файлы из каталога в каталог, Git хранит ветку в виде ссылки на коммит. Получается, что ветка представляет собой вершину серии коммитов, а не контейнер для коммитов. История ветки распространяется через иерархические отношения с другими коммитами.
> *git branch*  
выводит список имеющихся веток. 

> *git branch <название ветки>*  
создает новую ветку (появится новый указатель на ваш текущий коммит). 

Откуда Git узнает, какой именно коммит является текущим? Для этого он хранит специальный указатель HEAD. В Git он указывает на локальную ветку, в которой вы находитесь в данный момент. Пока это все еще ветка master. Команда git branch всего лишь создала новую ветку, но не перевела вас в нее.

>*git checkout <название ветки>* - переход на ветку.

>*git log --graph*  
добавляет небольшой ASCII-граф с историей ветвлений и слияний для данной ветки

>*git log --oneline --graph --all*  
выводит историю коммитов, показывая места расположения указателей и точки расхождения.
### Основы ветвления
В качестве исходных условий представим, что уже есть пара коммитов проекта.
Вы решили приступить к работе над проблемой 53, фигурирующей в системе отслеживания ошибок вашей фирмы. Создать ветку и сразу перейти туда позволяет *git checkout* с параметром *-b*:
>*git checkout -b* iss53 - переход на новую ветку "iss53"

Это сокращенная запись для команд:
>*git branch* iss53  
>*git checkout* iss53

Вы работаете, несколько раз фиксируете состояние. При этом ветка iss53 смещается вперед, так как вы в ней находитесь.  
Вдруг - звонок с сообщением о проблеме. Благодаря Git вам не нужно выполнять развертывание исправлений вместе с внесенными в ветку iss53 изменениями или ценой массы усилий отменять эти изменения перед тем, как приступить к устранению проблемы. Достаточно вернуться в ветку *master* (предварительно зафиксировав все изменения в той ветке).  
Теперь рабочая папка проекта вернулась в то состояние, в котором она пребывала перед началом работы над проблемой 53, и можно сконцентрироваться на решении новой задачи - новая ветка hotfix.
>*git checkout -b* hotfix  
.....  
>*git commit -a -m* 'fixed the broken email address'

![Ветка hotfix базируется на ветке master](branches.PNG)
Убедившись, что найденное решение работает, можно объединить ветку *hotfix* с веткой *master*, чтобы внедрить внесенные изменения в готовый код. Эта операция выполняется командой **git merge**:
>*git checkout master*  
>*git merge* hotfix

*git merge* вызывается из той ветки, в которую вы хотите залить изменения!

После внедрения важного исправления можно вернуться к прерванной работе. Но сначала следует удалить ветку *hotfix*, так как она нам больше не понадобится, — на этот коммит уже указывает ветка *master*.  
Для этого достаточно добавить параметр *-d* к команде git branch:
>*git branch -d* hotfix

Теперь можно вернуться в ветку, где ведется работа над проблемой 53, и продолжить ее решение.  
Следует заметить, что изменения, внесенные в ветку *hotfix*, не касаются файлов из ветки *iss53*. Ситуацию можно изменить, слив ветку *master* с веткой *iss53*, — это делает команда *git merge master*. Или отложите этот процесс до момента, пока решите включить содержимое ветки *iss53* в ветку *master*.
### Основы слияния
Предположим, работа над проблемой 53 завершена и вы готовы вставить сделанные изменения в ветку *master*.
>*git checkout master  
git merge* iss53

Но в данном случае наблюдаются отличия от ситуации со слиянием ветки *hotfix*. Дело в том, что в некоторой точке история разработки разделилась. Коммит, соответствующий текущей ветке, не является прямым предком для ветки, с которой осуществляется слияние. В рассматриваемом случае Git выполнит простое трехэтапное слияние, используя два состояния, на которые указывают вершины веток, и их общего предка:
![Три снимка состояния, используемые при типичном слиянии](branches2.PNG)
Вместо того чтобы просто сместить указатель ветки вперед, Git формирует новое состояние, возникающее из трехэтапного слияния, и автоматически создает коммит для этого состояния.
### Конфликты при слиянии
Процесс слияния далеко не всегда проходит гладко. Если в двух ветках, которые вы собираетесь слить, вы внесли разные изменения в один и тот же файл, Git не сможет просто взять и объединить их. Если бы при решении проблемы 53 вы отредактировали ту же самую часть файла, что и в ветке *hotfix*, возник бы конфликт слияния.  
Для разрешения конфликта следует или выбрать одну из версий, или каким-то образом объединить их.  
Разобравшись с каждым таким разделом в каждом из проблемных файлов, выполните для каждого из этих файлов команду *git add*. Индексируя файл, вы помечаете его как неконфликтующий.  
Убедиться в том, что конфликт разрешен, позволяет команда *git status*.  
Если вы довольны полученным результатом и удостоверились в том, что все ранее конфликтовавшие файлы проиндексированы, остается завершить слияние *git commit*. 
>*git reset --hard ####* - откат к указанному коммиту в рамках текущей ветки (по сути - отмена слияния).
## Другие советы и команды
>rm -R .git - удаление локального репозитория.

Папка в терминале должна совпадать с папкой в проводнике (Explorer).

>*git ls-tree* branch_name - перечисляет отслеживаемые в ветке файлы.

чтобы из репозитория снова сделать папку, достаточно всего лишь удалить скрытую папку «.git». При этом вы потеряете историю, которую собрал Git (все коммиты, ветки и т. п.), но файлы в самой папке останутся в том же виде, в котором они были в момент удаления папки «.git».

## Подсказки при работе с VS Code
Для начала работы выбрать папку, после чего запустить терминал.

Чтобы вызвать ранее введенную команду, перебираем недавно введенные команды нажатием стрелки «вверх» на клавиатуре.

Писать название целиком не обязательно: терминал дозаполнит данные автоматически, если нажать Tab после нескольки символов.

Нажатие клавиши ‘q’ возвращает в исходное окно терминала.

В терминале есть команда clear, очищающая поле от всех предыдущих записей.

>*touch* fix.txt - создание файла через терминал.

>*cd ..* - переход в родительский каталог (на один уровень вверх).

>*mv* old_name.txt new_name.txt - переименовать файл через терминал.

>*rm* fix.txt - удаление файла в текущем рабочем каталоге.