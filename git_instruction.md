# Git для новичков
## Что такое Git и зачем он нужен?
Git - это консольная утилита для отслеживания и ведения истории изменения файлов в вашем проекте.

Git сохраняет в памяти не файлы целиком, а разницу в них. С помощью Git-a вы можете откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.

Репозиторием называют хранилище вашего кода и истории его изменений.

Так же ваши репозитории можно хранить и в интернете. Обычно для этого используют три сервиса:
* GitHub
* Bitbucket
* GitLab

Каждая точка сохранения вашего проекта носит название коммит (commit). У каждого commit-a есть hash (уникальный id) и комментарий. Из таких commit-ов собирается ветка. Ветка - это история изменений. У каждой ветки есть свое название. Репозиторий может содержать в себе несколько веток, которые создаются из других веток или вливаются в них.
## Настройка
Прежде чем создавать репозиторий и инициализировать Git, проверим текущую установленную версию пограммы. Для этого в терминале введем команду:
> git --version

Если Git установлен на компьютер, вы увидите его текущую версию.

Чтобы когда вы создавали commit, указывался автор, кто его создал, установим имя и почту пользователя (кавычки нужны)  
>git config --global user.name "<ваше_имя>"  
git config --global user.email "<адрес_почты@email.com>"
## Инициализация/создание репозитория
Чтобы начать слежение за существующим проектом, перейдите в папку этого проекта и введите команду
>*git init* 

В результате в существующей папке появится скрытая папка .git со всеми нужными файлами репозитория.

Чтобы начать управление версиями, укажите файлы, за которыми должна следить система, и выполните первую фиксацию изменений.   
Добавим все файлы проекта в наш будующий commit:  
>*git add .*  
или  
>*git add --all*  

Если хотим добавить в отслеживаемые конкретные файлы, потребуется несколько команд *git add*:  
>*git add <имя_файла>*  
*git add <имя_файла>*

Теперь создаем commit. Обязательно указываем комментарий (*m*essage).
И не забываем про кавычки  
>*git commit -m "Initial commit"*

## Запись изменений в репозиторий
Не стоит после каждого изменения файла делать commit. Чаще всего их создают, когда:
* Создан новый функционал
* Добавлен новый блок на верстке
* Исправлены ошибки по коду
* Вы завершили рабочий день и хотите сохранить код.

Это поможет держать ваши ветки в чистоте и порядке. Тем самым вы будете видеть историю изменений по каждому нововведению в вашем проекте, а не по каждому файлу.

### Проверка состояния файлов
>*git status*  
отображает состояние рабочего каталога и раздела проиндексированных файлов. С ее помощью можно проверить индексацию изменений и увидеть файлы, которые не отслеживаются Git.
### Слежение за новыми файлами
>*git add <имя_файла>* 

Теперь команда *git status* покажет, что этот файл является отслеживаемым и проиндексированным.
### Индексация измененных файлов
>В дальнейшем, перед командами *git add* или *git commit -am* не забывать сохранять файл!

Если отредактировать отслеживаемый файл и воспользоваться командой git status, файл появляется под заголовком *Changed but not staged for commit* — это означает, что отслеживаемый файл из рабочей папки был изменен, но пока не проиндексирован. Индексирование выполняется командой 
>*git add <имя_файла>*  
Это многоцелевая команда, позволяющая начать слежение за новыми файлами, произвести индексирование файлов, а также пометить файлы с конфликтом слияния как разрешенные. Целесообразнее воспринимать эту команду как *«добавление содержимого к следующему коммиту»*, а не как «добавление файла к проекту». 

Git индексирует файл в том состоянии, в котором он пребывал на момент выполнения команды git add. Если внести в файл изменения до его фиксации, в коммит войдет версия файла, появившаяся после последнего запуска команды git add, а не версия, находившаяся в рабочей папке при запуске команды git commit! Редактирование файла после выполнения команды git add требует повторного запуска этой команды для индексирования самой последней версии файла.
>*git diff* - разница между текущим файлом и сохраненным коммитом.
### Фиксация изменений
>*git commit -m "<комментарий>"*  
фиксирует изменения.

При каждой фиксации вы записываете снимоксвоего проекта, к которому можно будет вернуться в любой момент или использовать его для сравнения с текущим состоянием.
### Пропуск области индексирования
Если передать команде *git commit* параметр *-a*, Git начнет автоматически индексировать **все** отслеживаемые файлы перед их фиксацией, позволяя обойтись без команды git add:
>*git commit -am "updated this section"*
### Удаление файлов
Чтобы Git перестал работать с файлом, его нужно удалить из числа отслеживаемых. Это делает команда 
>*git rm*  
которая заодно удаляет указанный файл из рабочей папки, благодаря чему он исчезает из списка неотслеживаемых.

После простого удаления файла из рабочей папки он появляется в разделе *Changed but not updated* (измененные, но необновленные) выводимых командой git status данных.

Иногда требуется оставить файл в рабочей папке, удалив его из области индексирования. В этом случае на помощь приходит параметр --cached:
>*git rm --cached <имя файла>*
## Просмотр истории версий
>*git log* - журнал изменений. Выводит список всех коммитов в хронологическом порядке.  
*git log --oneline* - краткая инфа. Достаточно, если работаешь один.
## Отмена изменений
Если после фиксации очередной версии вы обнаружили, что забыли проиндексировать изменения в одном из файлов, который планировалось включить в новый коммит, можно сделать так:
>*git commit -m 'изначальный коммит'  
git add <forgotten_file>  
git commit --amend*

В итоге у вас останется единственный коммит — второй коммит заменит результат первого.
### Отмена индексирования
Предположим, вы отредактировали два файла и хотели бы зафиксировать их в двух разных коммитах, но случайно набрали команду *git add .*, что привело к их одновременному индексированию.  
Для отмены индексирования следует воспользоваться командой 
>*git reset HEAD <имя файла>*
### Отмена внесенных в файл изменений
Как быстро отменить изменения и вернуть файл в состояние,
в котором он находился до последней фиксации? 
>*git checkout -- <имя файла>*  
Все внесенные в файл изменения пропадают — вы просто копируете в этот файл содержимое другого файла. Никогда не пользуйтесь этой командой, если не уверены, что данный файл вам больше не понадобится.

Перед переключением версии файла в Git используйте команду git log, чтобы увидеть количество сохранений и номер коммита.
>*git checkout ####* - переключение между версиями (где #### - первые символы номера коммита)

Для работы нужно указать не только интересующий вас коммит, но и вернуться в тот, где работаем, при помощи команды 
>*git checkout branchname* (где branchname - название ветви, в которой работаем).

Git отслеживает файлы по имени!  
Если изменить имя файла, Git будет считать, что он удален. Вместо этого появится новый файл, название которого Git пока неизвестно. Он его еще не отслеживает. В этом случае мы можем добавить свой файл с правильным именем в отслеживаемые, сделать новый commit, и всё снова будет в порядке. А при помощи *checkout* можно всё еще вернуться к любой версии.

## Работа с ветками
> *git branch*  
выводит список имеющихся веток. 

> *git branch <название ветки>*  
создает новую ветку.

>*git log --graph*  
добавляет небольшой ASCII-граф
с историей ветвлений и слияний
## Другие советы и команды
>rm -R .git - удаление локального репозитория.

Не создавать репозиторий внутри другого репозитория!

Папка в терминале должна совпадать с папкой в проводнике (Explorer).

## Подсказки при работе с VS Code
Для начала работы выбрать папку, после чего запустить терминал.

Чтобы вызвать ранее введенную команду, перебираем недавно введенные команды нажатием стрелки «вверх» на клавиатуре.

Писать название целиком не обязательно: терминал дозаполнит данные автоматически, если нажать Tab после нескольки символов.

Нажатие клавиши ‘q’ возвращает в исходное окно терминала.
